# SOME DESCRIPTIVE TITLE.
# Copyright (C) charles leifer
# This file is distributed under the same license as the peewee package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: peewee 3.13.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-03-04 10:15+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../peewee/querying.rst:4
msgid "Querying"
msgstr ""

#: ../../peewee/querying.rst:6
msgid ""
"This section will cover the basic CRUD operations commonly performed on a"
" relational database:"
msgstr ""

#: ../../peewee/querying.rst:9
msgid ":py:meth:`Model.create`, for executing *INSERT* queries."
msgstr ""

#: ../../peewee/querying.rst:10
msgid ""
":py:meth:`Model.save` and :py:meth:`Model.update`, for executing *UPDATE*"
" queries."
msgstr ""

#: ../../peewee/querying.rst:12
msgid ""
":py:meth:`Model.delete_instance` and :py:meth:`Model.delete`, for "
"executing *DELETE* queries."
msgstr ""

#: ../../peewee/querying.rst:14
msgid ":py:meth:`Model.select`, for executing *SELECT* queries."
msgstr ""

#: ../../peewee/querying.rst:17
msgid ""
"There is also a large collection of example queries taken from the "
"`Postgresql Exercises <https://pgexercises.com/>`_ website. Examples are "
"listed on the :ref:`query examples <query_examples>` document."
msgstr ""

#: ../../peewee/querying.rst:22
msgid "Creating a new record"
msgstr ""

#: ../../peewee/querying.rst:24
msgid ""
"You can use :py:meth:`Model.create` to create a new model instance. This "
"method accepts keyword arguments, where the keys correspond to the names "
"of the model's fields. A new instance is returned and a row is added to "
"the table."
msgstr ""

#: ../../peewee/querying.rst:33
msgid ""
"This will *INSERT* a new row into the database. The primary key will "
"automatically be retrieved and stored on the model instance."
msgstr ""

#: ../../peewee/querying.rst:36
msgid ""
"Alternatively, you can build up a model instance programmatically and "
"then call :py:meth:`~Model.save`:"
msgstr ""

#: ../../peewee/querying.rst:53
msgid ""
"When a model has a foreign key, you can directly assign a model instance "
"to the foreign key field when creating a new record."
msgstr ""

#: ../../peewee/querying.rst:60
msgid "You can also use the value of the related object's primary key:"
msgstr ""

#: ../../peewee/querying.rst:66
msgid ""
"If you simply wish to insert data and do not need to create a model "
"instance, you can use :py:meth:`Model.insert`:"
msgstr ""

#: ../../peewee/querying.rst:74
msgid ""
"After executing the insert query, the primary key of the new row is "
"returned."
msgstr ""

#: ../../peewee/querying.rst:77
msgid ""
"There are several ways you can speed up bulk insert operations. Check out"
" the :ref:`bulk_inserts` recipe section for more information."
msgstr ""

#: ../../peewee/querying.rst:83
msgid "Bulk inserts"
msgstr ""

#: ../../peewee/querying.rst:85
msgid ""
"There are a couple of ways you can load lots of data quickly. The naive "
"approach is to simply call :py:meth:`Model.create` in a loop:"
msgstr ""

#: ../../peewee/querying.rst:99
msgid "The above approach is slow for a couple of reasons:"
msgstr ""

#: ../../peewee/querying.rst:101
msgid ""
"If you are not wrapping the loop in a transaction then each call to "
":py:meth:`~Model.create` happens in its own transaction. That is going to"
" be really slow!"
msgstr ""

#: ../../peewee/querying.rst:104
msgid ""
"There is a decent amount of Python logic getting in your way, and each "
":py:class:`InsertQuery` must be generated and parsed into SQL."
msgstr ""

#: ../../peewee/querying.rst:106
msgid ""
"That's a lot of data (in terms of raw bytes of SQL) you are sending to "
"your database to parse."
msgstr ""

#: ../../peewee/querying.rst:108
msgid ""
"We are retrieving the *last insert id*, which causes an additional query "
"to be executed in some cases."
msgstr ""

#: ../../peewee/querying.rst:111
msgid ""
"You can get a significant speedup by simply wrapping this in a "
"transaction with :py:meth:`~Database.atomic`."
msgstr ""

#: ../../peewee/querying.rst:121
msgid ""
"The above code still suffers from points 2, 3 and 4. We can get another "
"big boost by using :py:meth:`~Model.insert_many`. This method accepts a "
"list of tuples or dictionaries, and inserts multiple rows in a single "
"query:"
msgstr ""

#: ../../peewee/querying.rst:136
msgid ""
"The :py:meth:`~Model.insert_many` method also accepts a list of row-"
"tuples, provided you also specify the corresponding fields:"
msgstr ""

#: ../../peewee/querying.rst:149
msgid "It is also a good practice to wrap the bulk insert in a transaction:"
msgstr ""

#: ../../peewee/querying.rst:158
msgid ""
"SQLite users should be aware of some caveats when using bulk inserts. "
"Specifically, your SQLite3 version must be 3.7.11.0 or newer to take "
"advantage of the bulk insert API. Additionally, by default SQLite limits "
"the number of bound variables in a SQL query to ``999``."
msgstr ""

#: ../../peewee/querying.rst:164
msgid "Inserting rows in batches"
msgstr ""

#: ../../peewee/querying.rst:166
msgid ""
"Depending on the number of rows in your data source, you may need to "
"break it up into chunks. SQLite in particular typically has a `limit of "
"999 <https://www.sqlite.org/limits.html#max_variable_number>`_ variables-"
"per-query (batch size would then be roughly 1000 / row length)."
msgstr ""

#: ../../peewee/querying.rst:170
msgid ""
"You can write a loop to batch your data into chunks (in which case it is "
"**strongly recommended** you use a transaction):"
msgstr ""

#: ../../peewee/querying.rst:180
msgid ""
"Peewee comes with a :py:func:`chunked` helper function which you can use "
"for *efficiently* chunking a generic iterable into a series of "
"*batch*-sized iterables:"
msgstr ""

#: ../../peewee/querying.rst:194
msgid "Alternatives"
msgstr ""

#: ../../peewee/querying.rst:196
msgid ""
"The :py:meth:`Model.bulk_create` method behaves much like "
":py:meth:`Model.insert_many`, but instead it accepts a list of unsaved "
"model instances to insert, and it optionally accepts a batch-size "
"parameter. To use the :py:meth:`~Model.bulk_create` API:"
msgstr ""

#: ../../peewee/querying.rst:214
msgid ""
"If you are using Postgresql (which supports the ``RETURNING`` clause), "
"then the previously-unsaved model instances will have their new primary "
"key values automatically populated."
msgstr ""

#: ../../peewee/querying.rst:218
msgid ""
"In addition, Peewee also offers :py:meth:`Model.bulk_update`, which can "
"efficiently update one or more columns on a list of models. For example:"
msgstr ""

#: ../../peewee/querying.rst:235
msgid ""
"For large lists of objects, you should specify a reasonable batch_size "
"and wrap the call to :py:meth:`~Model.bulk_update` with "
":py:meth:`Database.atomic`:"
msgstr ""

#: ../../peewee/querying.rst:244
msgid ""
"Alternatively, you can use the :py:meth:`Database.batch_commit` helper to"
" process chunks of rows inside *batch*-sized transactions. This method "
"also provides a workaround for databases besides Postgresql, when the "
"primary-key of the newly-created rows must be obtained."
msgstr ""

#: ../../peewee/querying.rst:260
msgid "Bulk-loading from another table"
msgstr ""

#: ../../peewee/querying.rst:262
msgid ""
"If the data you would like to bulk load is stored in another table, you "
"can also create *INSERT* queries whose source is a *SELECT* query. Use "
"the :py:meth:`Model.insert_from` method:"
msgstr ""

#: ../../peewee/querying.rst:274
msgid "The above query is equivalent to the following SQL:"
msgstr ""

#: ../../peewee/querying.rst:283
msgid "Updating existing records"
msgstr ""

#: ../../peewee/querying.rst:285
msgid ""
"Once a model instance has a primary key, any subsequent call to "
":py:meth:`~Model.save` will result in an *UPDATE* rather than another "
"*INSERT*. The model's primary key will not change:"
msgstr ""

#: ../../peewee/querying.rst:303
msgid ""
"If you want to update multiple records, issue an *UPDATE* query. The "
"following example will update all ``Tweet`` objects, marking them as "
"*published*, if they were created before today. :py:meth:`Model.update` "
"accepts keyword arguments where the keys correspond to the model's field "
"names:"
msgstr ""

#: ../../peewee/querying.rst:315
msgid ""
"For more information, see the documentation on :py:meth:`Model.update`, "
":py:class:`Update` and :py:meth:`Model.bulk_update`."
msgstr ""

#: ../../peewee/querying.rst:319
msgid ""
"If you would like more information on performing atomic updates (such as "
"incrementing the value of a column), check out the :ref:`atomic update "
"<atomic_updates>` recipes."
msgstr ""

#: ../../peewee/querying.rst:326
msgid "Atomic updates"
msgstr ""

#: ../../peewee/querying.rst:328
msgid ""
"Peewee allows you to perform atomic updates. Let's suppose we need to "
"update some counters. The naive approach would be to write something like"
" this:"
msgstr ""

#: ../../peewee/querying.rst:337
msgid ""
"**Do not do this!** Not only is this slow, but it is also vulnerable to "
"race conditions if multiple processes are updating the counter at the "
"same time."
msgstr ""

#: ../../peewee/querying.rst:340
msgid ""
"Instead, you can update the counters atomically using "
":py:meth:`~Model.update`:"
msgstr ""

#: ../../peewee/querying.rst:347
#, python-format
msgid ""
"You can make these update statements as complex as you like. Let's give "
"all our employees a bonus equal to their previous bonus plus 10% of their"
" salary:"
msgstr ""

#: ../../peewee/querying.rst:355
msgid ""
"We can even use a subquery to update the value of a column. Suppose we "
"had a denormalized column on the ``User`` model that stored the number of"
" tweets a user had made, and we updated this value periodically. Here is "
"how you might write such a query:"
msgstr ""

#: ../../peewee/querying.rst:367
msgid "Upsert"
msgstr ""

#: ../../peewee/querying.rst:369
msgid ""
"Peewee provides support for varying types of upsert functionality. With "
"SQLite prior to 3.24.0 and MySQL, Peewee offers the "
":py:meth:`~Model.replace`, which allows you to insert a record or, in the"
" event of a constraint violation, replace the existing record."
msgstr ""

#: ../../peewee/querying.rst:374
msgid ""
"Example of using :py:meth:`~Model.replace` and "
":py:meth:`~Insert.on_conflict_replace`:"
msgstr ""

#: ../../peewee/querying.rst:395
msgid ""
"In addition to *replace*, SQLite, MySQL and Postgresql provide an "
"*ignore* action (see: :py:meth:`~Insert.on_conflict_ignore`) if you "
"simply wish to insert and ignore any potential constraint violation."
msgstr ""

#: ../../peewee/querying.rst:399
msgid ""
"**MySQL** supports upsert via the *ON DUPLICATE KEY UPDATE* clause. For "
"example:"
msgstr ""

#: ../../peewee/querying.rst:422 ../../peewee/querying.rst:454
msgid ""
"In the above example, we could safely invoke the upsert query as many "
"times as we wanted. The login count will be incremented atomically, the "
"last login column will be updated, and no duplicate rows will be created."
msgstr ""

#: ../../peewee/querying.rst:426
msgid ""
"**Postgresql and SQLite** (3.24.0 and newer) provide a different syntax "
"that allows for more granular control over which constraint violation "
"should trigger the conflict resolution, and what values should be updated"
" or preserved."
msgstr ""

#: ../../peewee/querying.rst:430
msgid ""
"Example of using :py:meth:`~Insert.on_conflict` to perform a Postgresql-"
"style upsert (or SQLite 3.24+):"
msgstr ""

#: ../../peewee/querying.rst:459
msgid ""
"The main difference between MySQL and Postgresql/SQLite is that "
"Postgresql and SQLite require that you specify a ``conflict_target``."
msgstr ""

#: ../../peewee/querying.rst:462
msgid ""
"Here is a more advanced (if contrived) example using the "
":py:class:`EXCLUDED` namespace. The :py:class:`EXCLUDED` helper allows us"
" to reference values in the conflicting data. For our example, we'll "
"assume a simple table mapping a unique key (string) to a value (integer):"
msgstr ""

#: ../../peewee/querying.rst:495
msgid ""
"For more information, see :py:meth:`Insert.on_conflict` and "
":py:class:`OnConflict`."
msgstr ""

#: ../../peewee/querying.rst:499
msgid "Deleting records"
msgstr ""

#: ../../peewee/querying.rst:501
msgid ""
"To delete a single model instance, you can use the "
":py:meth:`Model.delete_instance` shortcut. "
":py:meth:`~Model.delete_instance` will delete the given model instance "
"and can optionally delete any dependent objects recursively (by "
"specifying `recursive=True`)."
msgstr ""

#: ../../peewee/querying.rst:517
msgid ""
"To delete an arbitrary set of rows, you can issue a *DELETE* query. The "
"following will delete all ``Tweet`` objects that are over one year old:"
msgstr ""

#: ../../peewee/querying.rst:526 ../../peewee/querying.rst:578
msgid "For more information, see the documentation on:"
msgstr ""

#: ../../peewee/querying.rst:528
msgid ":py:meth:`Model.delete_instance`"
msgstr ""

#: ../../peewee/querying.rst:529
msgid ":py:meth:`Model.delete`"
msgstr ""

#: ../../peewee/querying.rst:530
msgid ":py:class:`DeleteQuery`"
msgstr ""

#: ../../peewee/querying.rst:533
msgid "Selecting a single record"
msgstr ""

#: ../../peewee/querying.rst:535
msgid ""
"You can use the :py:meth:`Model.get` method to retrieve a single instance"
" matching the given query. For primary-key lookups, you can also use the "
"shortcut method :py:meth:`Model.get_by_id`."
msgstr ""

#: ../../peewee/querying.rst:539
msgid ""
"This method is a shortcut that calls :py:meth:`Model.select` with the "
"given query, but limits the result set to a single row. Additionally, if "
"no model matches the given query, a ``DoesNotExist`` exception will be "
"raised."
msgstr ""

#: ../../peewee/querying.rst:565
msgid ""
"For more advanced operations, you can use :py:meth:`SelectBase.get`. The "
"following query retrieves the latest tweet from the user named *charlie*:"
msgstr ""

#: ../../peewee/querying.rst:580
msgid ":py:meth:`Model.get`"
msgstr ""

#: ../../peewee/querying.rst:581
msgid ":py:meth:`Model.get_by_id`"
msgstr ""

#: ../../peewee/querying.rst:582
msgid ""
":py:meth:`Model.get_or_none` - if no matching row is found, return "
"``None``."
msgstr ""

#: ../../peewee/querying.rst:583
msgid ":py:meth:`Model.first`"
msgstr ""

#: ../../peewee/querying.rst:584
msgid ":py:meth:`Model.select`"
msgstr ""

#: ../../peewee/querying.rst:585
msgid ":py:meth:`SelectBase.get`"
msgstr ""

#: ../../peewee/querying.rst:588
msgid "Create or get"
msgstr ""

#: ../../peewee/querying.rst:590
msgid ""
"Peewee has one helper method for performing \"get/create\" type "
"operations: :py:meth:`Model.get_or_create`, which first attempts to "
"retrieve the matching row. Failing that, a new row will be created."
msgstr ""

#: ../../peewee/querying.rst:594
msgid ""
"For \"create or get\" type logic, typically one would rely on a *unique* "
"constraint or primary key to prevent the creation of duplicate objects. "
"As an example, let's say we wish to implement registering a new user "
"account using the :ref:`example User model <blog-models>`. The *User* "
"model has a *unique* constraint on the username field, so we will rely on"
" the database's integrity guarantees to ensure we don't end up with "
"duplicate usernames:"
msgstr ""

#: ../../peewee/querying.rst:611
msgid ""
"You can easily encapsulate this type of logic as a ``classmethod`` on "
"your own ``Model`` classes."
msgstr ""

#: ../../peewee/querying.rst:614
msgid ""
"The above example first attempts at creation, then falls back to "
"retrieval, relying on the database to enforce a unique constraint. If you"
" prefer to attempt to retrieve the record first, you can use "
":py:meth:`~Model.get_or_create`. This method is implemented along the "
"same lines as the Django function of the same name. You can use the "
"Django-style keyword argument filters to specify your ``WHERE`` "
"conditions. The function returns a 2-tuple containing the instance and a "
"boolean value indicating if the object was created."
msgstr ""

#: ../../peewee/querying.rst:623
msgid ""
"Here is how you might implement user account creation using "
":py:meth:`~Model.get_or_create`:"
msgstr ""

#: ../../peewee/querying.rst:630
msgid ""
"Suppose we have a different model ``Person`` and would like to get or "
"create a person object. The only conditions we care about when retrieving"
" the ``Person`` are their first and last names, **but** if we end up "
"needing to create a new record, we will also specify their date-of-birth "
"and favorite color:"
msgstr ""

#: ../../peewee/querying.rst:642
msgid ""
"Any keyword argument passed to :py:meth:`~Model.get_or_create` will be "
"used in the ``get()`` portion of the logic, except for the ``defaults`` "
"dictionary, which will be used to populate values on newly-created "
"instances."
msgstr ""

#: ../../peewee/querying.rst:646
msgid ""
"For more details read the documentation for "
":py:meth:`Model.get_or_create`."
msgstr ""

#: ../../peewee/querying.rst:649
msgid "Selecting multiple records"
msgstr ""

#: ../../peewee/querying.rst:651
msgid ""
"We can use :py:meth:`Model.select` to retrieve rows from the table. When "
"you construct a *SELECT* query, the database will return any rows that "
"correspond to your query. Peewee allows you to iterate over these rows, "
"as well as use indexing and slicing operations:"
msgstr ""

#: ../../peewee/querying.rst:671
msgid ""
":py:class:`Select` queries are smart, in that you can iterate, index and "
"slice the query multiple times but the query is only executed once."
msgstr ""

#: ../../peewee/querying.rst:674
msgid ""
"In the following example, we will simply call :py:meth:`~Model.select` "
"and iterate over the return value, which is an instance of "
":py:class:`Select`. This will return all the rows in the *User* table:"
msgstr ""

#: ../../peewee/querying.rst:688
msgid ""
"Subsequent iterations of the same query will not hit the database as the "
"results are cached. To disable this behavior (to reduce memory usage), "
"call :py:meth:`Select.iterator` when iterating."
msgstr ""

#: ../../peewee/querying.rst:692
msgid ""
"When iterating over a model that contains a foreign key, be careful with "
"the way you access values on related models. Accidentally resolving a "
"foreign key or iterating over a back-reference can cause :ref:`N+1 query "
"behavior <nplusone>`."
msgstr ""

#: ../../peewee/querying.rst:696
msgid ""
"When you create a foreign key, such as ``Tweet.user``, you can use the "
"*backref* to create a back-reference (``User.tweets``). Back-references "
"are exposed as :py:class:`Select` instances:"
msgstr ""

#: ../../peewee/querying.rst:710
msgid ""
"You can iterate over the ``user.tweets`` back-reference just like any "
"other :py:class:`Select`:"
msgstr ""

#: ../../peewee/querying.rst:722
msgid ""
"In addition to returning model instances, :py:class:`Select` queries can "
"return dictionaries, tuples and namedtuples. Depending on your use-case, "
"you may find it easier to work with rows as dictionaries, for example:"
msgstr ""

#: ../../peewee/querying.rst:736
msgid ""
"See :py:meth:`~BaseQuery.namedtuples`, :py:meth:`~BaseQuery.tuples`, "
":py:meth:`~BaseQuery.dicts` for more information."
msgstr ""

#: ../../peewee/querying.rst:740
msgid "Iterating over large result-sets"
msgstr ""

#: ../../peewee/querying.rst:742
msgid ""
"By default peewee will cache the rows returned when iterating over a "
":py:class:`Select` query. This is an optimization to allow multiple "
"iterations as well as indexing and slicing without causing additional "
"queries. This caching can be problematic, however, when you plan to "
"iterate over a large number of rows."
msgstr ""

#: ../../peewee/querying.rst:748
msgid ""
"To reduce the amount of memory used by peewee when iterating over a "
"query, use the :py:meth:`~BaseQuery.iterator` method. This method allows "
"you to iterate without caching each model returned, using much less "
"memory when iterating over large result sets."
msgstr ""

#: ../../peewee/querying.rst:765
msgid ""
"For simple queries you can see further speed improvements by returning "
"rows as dictionaries, namedtuples or tuples. The following methods can be"
" used on any :py:class:`Select` query to change the result row type:"
msgstr ""

#: ../../peewee/querying.rst:769 ../../peewee/querying.rst:1666
msgid ":py:meth:`~BaseQuery.dicts`"
msgstr ""

#: ../../peewee/querying.rst:770 ../../peewee/querying.rst:1667
msgid ":py:meth:`~BaseQuery.namedtuples`"
msgstr ""

#: ../../peewee/querying.rst:771 ../../peewee/querying.rst:1668
msgid ":py:meth:`~BaseQuery.tuples`"
msgstr ""

#: ../../peewee/querying.rst:773
msgid ""
"Don't forget to append the :py:meth:`~BaseQuery.iterator` method call to "
"also reduce memory consumption. For example, the above code might look "
"like:"
msgstr ""

#: ../../peewee/querying.rst:788
msgid ""
"When iterating over a large number of rows that contain columns from "
"multiple tables, peewee will reconstruct the model graph for each row "
"returned. This operation can be slow for complex graphs. For example, if "
"we were selecting a list of tweets along with the username and avatar of "
"the tweet's author, Peewee would have to create two objects for each row "
"(a tweet and a user). In addition to the above row-types, there is a "
"fourth method :py:meth:`~BaseQuery.objects` which will return the rows as"
" model instances, but will not attempt to resolve the model graph."
msgstr ""

#: ../../peewee/querying.rst:797
msgid "For example:"
msgstr ""

#: ../../peewee/querying.rst:815
msgid ""
"For maximum performance, you can execute queries and then iterate over "
"the results using the underlying database cursor. "
":py:meth:`Database.execute` accepts a query object, executes the query, "
"and returns a DB-API 2.0 ``Cursor`` object. The cursor will return the "
"raw row-tuples:"
msgstr ""

#: ../../peewee/querying.rst:828
msgid "Filtering records"
msgstr ""

#: ../../peewee/querying.rst:830
msgid ""
"You can filter for particular records using normal python operators. "
"Peewee supports a wide variety of :ref:`query operators <query-"
"operators>`."
msgstr ""

#: ../../peewee/querying.rst:847
msgid "You can also filter across joins:"
msgstr ""

#: ../../peewee/querying.rst:857
msgid ""
"If you want to express a complex query, use parentheses and python's "
"bitwise *or* and *and* operators:"
msgstr ""

#: ../../peewee/querying.rst:867
msgid ""
"Note that Peewee uses **bitwise** operators (``&`` and ``|``) rather than"
" logical operators (``and`` and ``or``). The reason for this is that "
"Python coerces the return value of logical operations to a boolean value."
" This is also the reason why \"IN\" queries must be expressed using "
"``.in_()`` rather than the ``in`` operator."
msgstr ""

#: ../../peewee/querying.rst:873
msgid ""
"Check out :ref:`the table of query operations <query-operators>` to see "
"what types of queries are possible."
msgstr ""

#: ../../peewee/querying.rst:878
msgid "A lot of fun things can go in the where clause of a query, such as:"
msgstr ""

#: ../../peewee/querying.rst:880
msgid "A field expression, e.g. ``User.username == 'Charlie'``"
msgstr ""

#: ../../peewee/querying.rst:881
msgid ""
"A function expression, e.g. ``fn.Lower(fn.Substr(User.username, 1, 1)) =="
" 'a'``"
msgstr ""

#: ../../peewee/querying.rst:882
msgid ""
"A comparison of one column to another, e.g. ``Employee.salary < "
"(Employee.tenure * 1000) + 40000``"
msgstr ""

#: ../../peewee/querying.rst:884
msgid ""
"You can also nest queries, for example tweets by users whose username "
"starts with \"a\":"
msgstr ""

#: ../../peewee/querying.rst:896
msgid "More query examples"
msgstr ""

#: ../../peewee/querying.rst:899
msgid ""
"For a wide range of example queries, see the :ref:`Query Examples "
"<query_examples>` document, which shows how to implements queries from "
"the `PostgreSQL Exercises <https://pgexercises.com/>`_ website."
msgstr ""

#: ../../peewee/querying.rst:903
msgid "Get active users:"
msgstr ""

#: ../../peewee/querying.rst:909
msgid "Get users who are either staff or superusers:"
msgstr ""

#: ../../peewee/querying.rst:916
msgid "Get tweets by user named \"charlie\":"
msgstr ""

#: ../../peewee/querying.rst:922
msgid "Get tweets by staff or superusers (assumes FK relationship):"
msgstr ""

#: ../../peewee/querying.rst:929
msgid "Get tweets by staff or superusers using a subquery:"
msgstr ""

#: ../../peewee/querying.rst:938
msgid "Sorting records"
msgstr ""

#: ../../peewee/querying.rst:940
msgid "To return rows in order, use the :py:meth:`~Query.order_by` method:"
msgstr ""

#: ../../peewee/querying.rst:958
msgid "You can also use ``+`` and ``-`` prefix operators to indicate ordering:"
msgstr ""

#: ../../peewee/querying.rst:971
msgid ""
"You can also order across joins. Assuming you want to order tweets by the"
" username of the author, then by created_date:"
msgstr ""

#: ../../peewee/querying.rst:989
msgid ""
"When sorting on a calculated value, you can either include the necessary "
"SQL expressions, or reference the alias assigned to the value. Here are "
"two examples illustrating these methods:"
msgstr ""

#: ../../peewee/querying.rst:1003
msgid ""
"You can order using the same COUNT expression used in the ``select`` "
"clause. In the example below we are ordering by the ``COUNT()`` of tweet "
"ids descending:"
msgstr ""

#: ../../peewee/querying.rst:1014
msgid ""
"Alternatively, you can reference the alias assigned to the calculated "
"value in the ``select`` clause. This method has the benefit of being a "
"bit easier to read. Note that we are not referring to the named alias "
"directly, but are wrapping it using the :py:class:`SQL` helper:"
msgstr ""

#: ../../peewee/querying.rst:1027
msgid "Or, to do things the \"peewee\" way:"
msgstr ""

#: ../../peewee/querying.rst:1039
msgid "Getting random records"
msgstr ""

#: ../../peewee/querying.rst:1041
msgid ""
"Occasionally you may want to pull a random record from the database. You "
"can accomplish this by ordering by the *random* or *rand* function "
"(depending on your database):"
msgstr ""

#: ../../peewee/querying.rst:1045
msgid "Postgresql and Sqlite use the *Random* function:"
msgstr ""

#: ../../peewee/querying.rst:1052
msgid "MySQL uses *Rand*:"
msgstr ""

#: ../../peewee/querying.rst:1060
msgid "Paginating records"
msgstr ""

#: ../../peewee/querying.rst:1062
msgid ""
"The :py:meth:`~Query.paginate` method makes it easy to grab a *page* or "
"records. :py:meth:`~Query.paginate` takes two parameters, "
"``page_number``, and ``items_per_page``."
msgstr ""

#: ../../peewee/querying.rst:1067
msgid "Page numbers are 1-based, so the first page of results will be page 1."
msgstr ""

#: ../../peewee/querying.rst:1085
msgid ""
"If you would like more granular control, you can always use "
":py:meth:`~Query.limit` and :py:meth:`~Query.offset`."
msgstr ""

#: ../../peewee/querying.rst:1089
msgid "Counting records"
msgstr ""

#: ../../peewee/querying.rst:1091
msgid "You can count the number of rows in any select query:"
msgstr ""

#: ../../peewee/querying.rst:1100
msgid ""
"Peewee will wrap your query in an outer query that performs a count, "
"which results in SQL like:"
msgstr ""

#: ../../peewee/querying.rst:1108
msgid "Aggregating records"
msgstr ""

#: ../../peewee/querying.rst:1110
msgid ""
"Suppose you have some users and want to get a list of them along with the"
" count of tweets in each."
msgstr ""

#: ../../peewee/querying.rst:1120
msgid ""
"The resulting query will return *User* objects with all their normal "
"attributes plus an additional attribute *count* which will contain the "
"count of tweets for each user. We use a left outer join to include users "
"who have no tweets."
msgstr ""

#: ../../peewee/querying.rst:1124
msgid ""
"Let's assume you have a tagging application and want to find tags that "
"have a certain number of related objects. For this example we'll use some"
" different models in a :ref:`many-to-many <manytomany>` configuration:"
msgstr ""

#: ../../peewee/querying.rst:1140
msgid ""
"Now say we want to find tags that have at least 5 photos associated with "
"them:"
msgstr ""

#: ../../peewee/querying.rst:1151
msgid "This query is equivalent to the following SQL:"
msgstr ""

#: ../../peewee/querying.rst:1162
msgid "Suppose we want to grab the associated count and store it on the tag:"
msgstr ""

#: ../../peewee/querying.rst:1174
msgid "Retrieving Scalar Values"
msgstr ""

#: ../../peewee/querying.rst:1176
msgid ""
"You can retrieve scalar values by calling :py:meth:`Query.scalar`. For "
"instance:"
msgstr ""

#: ../../peewee/querying.rst:1184
msgid "You can retrieve multiple scalar values by passing ``as_tuple=True``:"
msgstr ""

#: ../../peewee/querying.rst:1196
msgid "Window functions"
msgstr ""

#: ../../peewee/querying.rst:1198
msgid ""
"A :py:class:`Window` function refers to an aggregate function that "
"operates on a sliding window of data that is being processed as part of a"
" ``SELECT`` query. Window functions make it possible to do things like:"
msgstr ""

#: ../../peewee/querying.rst:1202
msgid "Perform aggregations against subsets of a result-set."
msgstr ""

#: ../../peewee/querying.rst:1203
msgid "Calculate a running total."
msgstr ""

#: ../../peewee/querying.rst:1204
msgid "Rank results."
msgstr ""

#: ../../peewee/querying.rst:1205
msgid "Compare a row value to a value in the preceding (or succeeding!) row(s)."
msgstr ""

#: ../../peewee/querying.rst:1207
msgid ""
"peewee comes with support for SQL window functions, which can be created "
"by calling :py:meth:`Function.over` and passing in your partitioning or "
"ordering parameters."
msgstr ""

#: ../../peewee/querying.rst:1211
msgid "For the following examples, we'll use the following model and sample data:"
msgstr ""

#: ../../peewee/querying.rst:1226
msgid "Our sample table now contains:"
msgstr ""

#: ../../peewee/querying.rst:1229 ../../peewee/querying.rst:1534
msgid "id"
msgstr ""

#: ../../peewee/querying.rst:1229 ../../peewee/querying.rst:1534
msgid "counter"
msgstr ""

#: ../../peewee/querying.rst:1229 ../../peewee/querying.rst:1534
msgid "value"
msgstr ""

#: ../../peewee/querying.rst:1231 ../../peewee/querying.rst:1232
#: ../../peewee/querying.rst:1536 ../../peewee/querying.rst:1537
#: ../../peewee/querying.rst:1541
msgid "1"
msgstr ""

#: ../../peewee/querying.rst:1231 ../../peewee/querying.rst:1536
msgid "10.0"
msgstr ""

#: ../../peewee/querying.rst:1232 ../../peewee/querying.rst:1233
#: ../../peewee/querying.rst:1234 ../../peewee/querying.rst:1537
#: ../../peewee/querying.rst:1538 ../../peewee/querying.rst:1539
#: ../../peewee/querying.rst:1542
msgid "2"
msgstr ""

#: ../../peewee/querying.rst:1232 ../../peewee/querying.rst:1537
#: ../../peewee/querying.rst:1541
msgid "20.0"
msgstr ""

#: ../../peewee/querying.rst:1233 ../../peewee/querying.rst:1235
#: ../../peewee/querying.rst:1538 ../../peewee/querying.rst:1540
msgid "3"
msgstr ""

#: ../../peewee/querying.rst:1233 ../../peewee/querying.rst:1538
#: ../../peewee/querying.rst:1542
msgid "1.0"
msgstr ""

#: ../../peewee/querying.rst:1234 ../../peewee/querying.rst:1539
msgid "4"
msgstr ""

#: ../../peewee/querying.rst:1234 ../../peewee/querying.rst:1539
msgid "3.0"
msgstr ""

#: ../../peewee/querying.rst:1235 ../../peewee/querying.rst:1540
msgid "5"
msgstr ""

#: ../../peewee/querying.rst:1235 ../../peewee/querying.rst:1540
msgid "100.0"
msgstr ""

#: ../../peewee/querying.rst:1239
msgid "Ordered Windows"
msgstr ""

#: ../../peewee/querying.rst:1241
msgid ""
"Let's calculate a running sum of the ``value`` field. In order for it to "
"be a \"running\" sum, we need it to be ordered, so we'll order with "
"respect to the Sample's ``id`` field:"
msgstr ""

#: ../../peewee/querying.rst:1261
msgid ""
"For another example, we'll calculate the difference between the current "
"value and the previous value, when ordered by the ``id``:"
msgstr ""

#: ../../peewee/querying.rst:1282
msgid "Partitioned Windows"
msgstr ""

#: ../../peewee/querying.rst:1284
msgid ""
"Let's calculate the average ``value`` for each distinct \"counter\" "
"value. Notice that there are three possible values for the ``counter`` "
"field (1, 2, and 3). We can do this by calculating the ``AVG()`` of the "
"``value`` column over a window that is partitioned depending on the "
"``counter`` field:"
msgstr ""

#: ../../peewee/querying.rst:1305
msgid ""
"We can use ordering within partitions by specifying both the ``order_by``"
" and ``partition_by`` parameters. For an example, let's rank the samples "
"by value within each distinct ``counter`` group."
msgstr ""

#: ../../peewee/querying.rst:1328
msgid "Bounded windows"
msgstr ""

#: ../../peewee/querying.rst:1330
msgid ""
"By default, window functions are evaluated using an *unbounded preceding*"
" start for the window, and the *current row* as the end. We can change "
"the bounds of the window our aggregate functions operate on by specifying"
" a ``start`` and/or ``end`` in the call to :py:meth:`Function.over`. "
"Additionally, Peewee comes with helper-methods on the :py:class:`Window` "
"object for generating the appropriate boundary references:"
msgstr ""

#: ../../peewee/querying.rst:1337
msgid ":py:attr:`Window.CURRENT_ROW` - attribute that references the current row."
msgstr ""

#: ../../peewee/querying.rst:1338
msgid ""
":py:meth:`Window.preceding` - specify number of row(s) preceding, or omit"
" number to indicate **all** preceding rows."
msgstr ""

#: ../../peewee/querying.rst:1340
msgid ""
":py:meth:`Window.following` - specify number of row(s) following, or omit"
" number to indicate **all** following rows."
msgstr ""

#: ../../peewee/querying.rst:1343
msgid ""
"To examine how boundaries work, we'll calculate a running total of the "
"``value`` column, ordered with respect to ``id``, **but** we'll only look"
" the running total of the current row and it's two preceding rows:"
msgstr ""

#: ../../peewee/querying.rst:1367
msgid ""
"Technically we did not need to specify the ``end=Window.CURRENT`` because"
" that is the default. It was shown in the example for demonstration."
msgstr ""

#: ../../peewee/querying.rst:1370
msgid ""
"Let's look at another example. In this example we will calculate the "
"\"opposite\" of a running total, in which the total sum of all values is "
"decreased by the value of the samples, ordered by ``id``. To accomplish "
"this, we'll calculate the sum from the current row to the last row."
msgstr ""

#: ../../peewee/querying.rst:1392
msgid "Filtered Aggregates"
msgstr ""

#: ../../peewee/querying.rst:1394
msgid ""
"Aggregate functions may also support filter functions (Postgres and "
"Sqlite 3.25+), which get translated into a ``FILTER (WHERE...)`` clause. "
"Filter expressions are added to an aggregate function with the "
":py:meth:`Function.filter` method."
msgstr ""

#: ../../peewee/querying.rst:1399
msgid ""
"For an example, we will calculate the running sum of the ``value`` field "
"with respect to the ``id``, but we will filter-out any samples whose "
"``counter=2``."
msgstr ""

#: ../../peewee/querying.rst:1420
msgid ""
"The call to :py:meth:`~Function.filter` must precede the call to "
":py:meth:`~Function.over`."
msgstr ""

#: ../../peewee/querying.rst:1424
msgid "Reusing Window Definitions"
msgstr ""

#: ../../peewee/querying.rst:1426
msgid ""
"If you intend to use the same window definition for multiple aggregates, "
"you can create a :py:class:`Window` object. The :py:class:`Window` object"
" takes the same parameters as :py:meth:`Function.over`, and can be passed"
" to the ``over()`` method in-place of the individual parameters."
msgstr ""

#: ../../peewee/querying.rst:1431
msgid ""
"Here we'll declare a single window, ordered with respect to the sample "
"``id``, and call several window functions using that window definition:"
msgstr ""

#: ../../peewee/querying.rst:1456
msgid "Multiple window definitions"
msgstr ""

#: ../../peewee/querying.rst:1458
msgid ""
"In the previous example, we saw how to declare a :py:class:`Window` "
"definition and re-use it for multiple different aggregations. You can "
"include as many window definitions as you need in your queries, but it is"
" necessary to ensure each window has a unique alias:"
msgstr ""

#: ../../peewee/querying.rst:1484
msgid ""
"Similarly, if you have multiple window definitions that share similar "
"definitions, it is possible to extend a previously-defined window "
"definition. For example, here we will be partitioning the data-set by the"
" counter value, so we'll be doing our aggregations with respect to the "
"counter. Then we'll define a second window that extends this "
"partitioning, and adds an ordering clause:"
msgstr ""

#: ../../peewee/querying.rst:1518
msgid "Frame types: RANGE vs ROWS vs GROUPS"
msgstr ""

#: ../../peewee/querying.rst:1520
msgid ""
"Depending on the frame type, the database will process ordered groups "
"differently. Let's create two additional ``Sample`` rows to visualize the"
" difference:"
msgstr ""

#: ../../peewee/querying.rst:1531
msgid "Our table now contains:"
msgstr ""

#: ../../peewee/querying.rst:1541
msgid "6"
msgstr ""

#: ../../peewee/querying.rst:1542
msgid "7"
msgstr ""

#: ../../peewee/querying.rst:1545
msgid ""
"Let's examine the difference by calculating a \"running sum\" of the "
"samples, ordered with respect to the ``counter`` and ``value`` fields. To"
" specify the frame type, we can use either:"
msgstr ""

#: ../../peewee/querying.rst:1549
msgid ":py:attr:`Window.RANGE`"
msgstr ""

#: ../../peewee/querying.rst:1550
msgid ":py:attr:`Window.ROWS`"
msgstr ""

#: ../../peewee/querying.rst:1551
msgid ":py:attr:`Window.GROUPS`"
msgstr ""

#: ../../peewee/querying.rst:1553
msgid ""
"The behavior of :py:attr:`~Window.RANGE`, when there are logical "
"duplicates, may lead to unexpected results:"
msgstr ""

#: ../../peewee/querying.rst:1577
msgid ""
"With the inclusion of the new rows we now have some rows that have "
"duplicate ``category`` and ``value`` values. The :py:attr:`~Window.RANGE`"
" frame type causes these duplicates to be evaluated together rather than "
"separately."
msgstr ""

#: ../../peewee/querying.rst:1581
msgid ""
"The more expected result can be achieved by using :py:attr:`~Window.ROWS`"
" as the frame-type:"
msgstr ""

#: ../../peewee/querying.rst:1605
msgid "Peewee uses these rules for determining what frame-type to use:"
msgstr ""

#: ../../peewee/querying.rst:1607
msgid "If the user specifies a ``frame_type``, that frame type will be used."
msgstr ""

#: ../../peewee/querying.rst:1608
msgid ""
"If ``start`` and/or ``end`` boundaries are specified Peewee will default "
"to using ``ROWS``."
msgstr ""

#: ../../peewee/querying.rst:1610
msgid ""
"If the user did not specify frame type or start/end boundaries, Peewee "
"will use the database default, which is ``RANGE``."
msgstr ""

#: ../../peewee/querying.rst:1613
msgid ""
"The :py:attr:`Window.GROUPS` frame type looks at the window range "
"specification in terms of groups of rows, based on the ordering term(s). "
"Using ``GROUPS``, we can define the frame so it covers distinct groupings"
" of rows. Let's look at an example:"
msgstr ""

#: ../../peewee/querying.rst:1640
msgid ""
"As you can hopefully infer, the window is grouped by its ordering term, "
"which is ``(counter, value)``. We are looking at a window that extends "
"between one previous group and the current group."
msgstr ""

#: ../../peewee/querying.rst:1645
msgid "For information about the window function APIs, see:"
msgstr ""

#: ../../peewee/querying.rst:1647
msgid ":py:meth:`Function.over`"
msgstr ""

#: ../../peewee/querying.rst:1648
msgid ":py:meth:`Function.filter`"
msgstr ""

#: ../../peewee/querying.rst:1649
msgid ":py:class:`Window`"
msgstr ""

#: ../../peewee/querying.rst:1651
msgid ""
"For general information on window functions, read the postgres `window "
"functions tutorial <https://www.postgresql.org/docs/current/tutorial-"
"window.html>`_"
msgstr ""

#: ../../peewee/querying.rst:1653
msgid ""
"Additionally, the `postgres docs <https://www.postgresql.org/docs/current"
"/sql-select.html#SQL-WINDOW>`_ and the `sqlite docs "
"<https://www.sqlite.org/windowfunctions.html>`_ contain a lot of good "
"information."
msgstr ""

#: ../../peewee/querying.rst:1660
msgid "Retrieving row tuples / dictionaries / namedtuples"
msgstr ""

#: ../../peewee/querying.rst:1662
msgid ""
"Sometimes you do not need the overhead of creating model instances and "
"simply want to iterate over the row data without needing all the APIs "
"provided :py:class:`Model`. To do this, use:"
msgstr ""

#: ../../peewee/querying.rst:1669
msgid ""
":py:meth:`~BaseQuery.objects` -- accepts an arbitrary constructor "
"function which is called with the row tuple."
msgstr ""

#: ../../peewee/querying.rst:1683
msgid ""
"Similarly, you can return the rows from the cursor as dictionaries using "
":py:meth:`~BaseQuery.dicts`:"
msgstr ""

#: ../../peewee/querying.rst:1700
msgid "Returning Clause"
msgstr ""

#: ../../peewee/querying.rst:1702
msgid ""
":py:class:`PostgresqlDatabase` supports a ``RETURNING`` clause on "
"``UPDATE``, ``INSERT`` and ``DELETE`` queries. Specifying a ``RETURNING``"
" clause allows you to iterate over the rows accessed by the query."
msgstr ""

#: ../../peewee/querying.rst:1706
msgid "By default, the return values upon execution of the different queries are:"
msgstr ""

#: ../../peewee/querying.rst:1708
msgid ""
"``INSERT`` - auto-incrementing primary key value of the newly-inserted "
"row. When not using an auto-incrementing primary key, Postgres will "
"return the new row's primary key, but SQLite and MySQL will not."
msgstr ""

#: ../../peewee/querying.rst:1711
msgid "``UPDATE`` - number of rows modified"
msgstr ""

#: ../../peewee/querying.rst:1712
msgid "``DELETE`` - number of rows deleted"
msgstr ""

#: ../../peewee/querying.rst:1714
msgid ""
"When a returning clause is used the return value upon executing a query "
"will be an iterable cursor object."
msgstr ""

#: ../../peewee/querying.rst:1717
msgid ""
"Postgresql allows, via the ``RETURNING`` clause, to return data from the "
"rows inserted or modified by a query."
msgstr ""

#: ../../peewee/querying.rst:1720
msgid ""
"For example, let's say you have an :py:class:`Update` that deactivates "
"all user accounts whose registration has expired. After deactivating "
"them, you want to send each user an email letting them know their account"
" was deactivated. Rather than writing two queries, a ``SELECT`` and an "
"``UPDATE``, you can do this in a single ``UPDATE`` query with a "
"``RETURNING`` clause:"
msgstr ""

#: ../../peewee/querying.rst:1737
msgid ""
"The ``RETURNING`` clause is also available on :py:class:`Insert` and "
":py:class:`Delete`. When used with ``INSERT``, the newly-created rows "
"will be returned. When used with ``DELETE``, the deleted rows will be "
"returned."
msgstr ""

#: ../../peewee/querying.rst:1741
msgid ""
"The only limitation of the ``RETURNING`` clause is that it can only "
"consist of columns from tables listed in the query's ``FROM`` clause. To "
"select all columns from a particular table, you can simply pass in the "
":py:class:`Model` class."
msgstr ""

#: ../../peewee/querying.rst:1746
msgid ""
"As another example, let's add a user and set their creation-date to the "
"server-generated current timestamp. We'll create and retrieve the new "
"user's ID, Email and the creation timestamp in a single query:"
msgstr ""

#: ../../peewee/querying.rst:1763
msgid ""
"By default the cursor will return :py:class:`Model` instances, but you "
"can specify a different row type:"
msgstr ""

#: ../../peewee/querying.rst:1777
msgid ""
"Just as with :py:class:`Select` queries, you can specify various "
":ref:`result row types <rowtypes>`."
msgstr ""

#: ../../peewee/querying.rst:1782
msgid "Common Table Expressions"
msgstr ""

#: ../../peewee/querying.rst:1784
msgid ""
"Peewee supports the inclusion of common table expressions (CTEs) in all "
"types of queries. CTEs may be useful for:"
msgstr ""

#: ../../peewee/querying.rst:1787
msgid "Factoring out a common subquery."
msgstr ""

#: ../../peewee/querying.rst:1788
msgid "Grouping or filtering by a column derived in the CTE's result set."
msgstr ""

#: ../../peewee/querying.rst:1789
msgid "Writing recursive queries."
msgstr ""

#: ../../peewee/querying.rst:1791
msgid ""
"To declare a :py:class:`Select` query for use as a CTE, use "
":py:meth:`~SelectQuery.cte` method, which wraps the query in a "
":py:class:`CTE` object. To indicate that a :py:class:`CTE` should be "
"included as part of a query, use the :py:meth:`Query.with_cte` method, "
"passing a list of CTE objects."
msgstr ""

#: ../../peewee/querying.rst:1797
msgid "Simple Example"
msgstr ""

#: ../../peewee/querying.rst:1799
msgid ""
"For an example, let's say we have some data points that consist of a key "
"and a floating-point value. Let's define our model and populate some test"
" data:"
msgstr ""

#: ../../peewee/querying.rst:1818
msgid ""
"Let's use a CTE to calculate, for each distinct key, which values were "
"above-average for that key."
msgstr ""

#: ../../peewee/querying.rst:1840
msgid ""
"We can iterate over the samples returned by the query to see which "
"samples had above-average values for their given group:"
msgstr ""

#: ../../peewee/querying.rst:1853
msgid "Complex Example"
msgstr ""

#: ../../peewee/querying.rst:1855
msgid ""
"For a more complete example, let's consider the following query which "
"uses multiple CTEs to find per-product sales totals in only the top sales"
" regions. Our model looks like this:"
msgstr ""

#: ../../peewee/querying.rst:1867
msgid ""
"Here is how the query might be written in SQL. This example can be found "
"in the `postgresql documentation "
"<https://www.postgresql.org/docs/current/static/queries-with.html>`_."
msgstr ""

#: ../../peewee/querying.rst:1889
msgid "With Peewee, we would write:"
msgstr ""

#: ../../peewee/querying.rst:1915
msgid "Recursive CTEs"
msgstr ""

#: ../../peewee/querying.rst:1917
msgid ""
"Peewee supports recursive CTEs. Recursive CTEs can be useful when, for "
"example, you have a tree data-structure represented by a parent-link "
"foreign key. Suppose, for example, that we have a hierarchy of categories"
" for an online bookstore. We wish to generate a table showing all "
"categories and their absolute depths, along with the path from the root "
"to the category."
msgstr ""

#: ../../peewee/querying.rst:1923
msgid ""
"We'll assume the following model definition, in which each category has a"
" foreign-key to its immediate parent category:"
msgstr ""

#: ../../peewee/querying.rst:1932
msgid ""
"To list all categories along with their depth and parents, we can use a "
"recursive CTE:"
msgstr ""

#: ../../peewee/querying.rst:1979
msgid "Foreign Keys and Joins"
msgstr ""

#: ../../peewee/querying.rst:1981
msgid "This section have been moved into its own document: :ref:`relationships`."
msgstr ""

