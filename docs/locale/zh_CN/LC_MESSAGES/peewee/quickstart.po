# SOME DESCRIPTIVE TITLE.
# Copyright (C) charles leifer
# This file is distributed under the same license as the peewee package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: peewee 3.13.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-03-04 10:15+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Sinchard <sinchard420@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../peewee/quickstart.rst:4
msgid "Quickstart"
msgstr "快速入门"

#: ../../peewee/quickstart.rst:6
msgid ""
"This document presents a brief, high-level overview of Peewee's primary "
"features. This guide will cover:"
msgstr "本文档简要概述了Peewee的主要功能，主要包括以下几部分："

#: ../../peewee/quickstart.rst:9
msgid ":ref:`model-definition`"
msgstr ":ref:`model-definition`"

#: ../../peewee/quickstart.rst:10
msgid ":ref:`storing-data`"
msgstr ":ref:`storing-data`"

#: ../../peewee/quickstart.rst:11
msgid ":ref:`retrieving-data`"
msgstr ":ref:`retrieving-data`"

#: ../../peewee/quickstart.rst:14
msgid ""
"If you'd like something a bit more meaty, there is a thorough tutorial on"
" :ref:`creating a \"twitter\"-style web app <example-app>` using peewee "
"and the Flask framework. In the projects ``examples/`` folder you can "
"find more self-contained Peewee examples, like a `blog app "
"<https://github.com/coleifer/peewee/tree/master/examples/blog>`_."
msgstr ""
"如果你想了解更深入的内容，这里有一个关于使用peewee和Flask框架创建"
":ref:`creating a \"twitter\"风格的web应用的完整教程。在项目``examples/``文件夹中，"
"您可以找到更多的Peewee示例，比如博客应用程序。"

#: ../../peewee/quickstart.rst:19
msgid ""
"I **strongly** recommend opening an interactive shell session and running"
" the code. That way you can get a feel for typing in queries."
msgstr ""
"我**强烈**建议打开一个交互式shell会话并运行代码，这样做感受更加的直观。"

#: ../../peewee/quickstart.rst:25
msgid "Model Definition"
msgstr "模型定义"

#: ../../peewee/quickstart.rst:27
msgid "Model classes, fields and model instances all map to database concepts:"
msgstr "模型类、字段和模型实例都将映射到数据库："

#: ../../peewee/quickstart.rst:30
msgid "Object"
msgstr "对象"

#: ../../peewee/quickstart.rst:30
msgid "Corresponds to..."
msgstr "对应于..."

#: ../../peewee/quickstart.rst:32
msgid "Model class"
msgstr "模型类"

#: ../../peewee/quickstart.rst:32
msgid "Database table"
msgstr "数据库表"

#: ../../peewee/quickstart.rst:33
msgid "Field instance"
msgstr "字段实例"

#: ../../peewee/quickstart.rst:33
msgid "Column on a table"
msgstr "表的列"

#: ../../peewee/quickstart.rst:34
msgid "Model instance"
msgstr "模型实例"

#: ../../peewee/quickstart.rst:34
msgid "Row in a database table"
msgstr "数据库表的一行数据"

#: ../../peewee/quickstart.rst:37
msgid ""
"When starting a project with peewee, it's typically best to begin with "
"your data model, by defining one or more :py:class:`Model` classes:"
msgstr ""
"当新建一个使用peewee的项目时，通常最好从数据模型开始：定义一个或多个模型类。"

#: ../../peewee/quickstart.rst:54
msgid ""
"Peewee will automatically infer the database table name from the name of "
"the class. You can override the default name by specifying a "
"``table_name`` attribute in the inner \"Meta\" class (alongside the "
"``database`` attribute). To learn more about how Peewee generates table "
"names, refer to the :ref:`table_names` section."
msgstr ""
"Peewee将自动根据类名确定数据库表名。您可以通过在内部\"Meta\"类中指定``table_name``"
"属性（在``database`` 属性旁边）来覆盖默认名称。要了解Peewee如何生成表名的更多信息，"
"请参阅:ref:`table_names`部分。"

#: ../../peewee/quickstart.rst:60
msgid ""
"Also note that we named our model ``Person`` instead of ``People``. This "
"is a convention you should follow -- even though the table will contain "
"multiple people, we always name the class using the singular form."
msgstr ""
"还要注意的是，我们将模特名称定义为``Person``而不是``People``。这是一个您应该"
"遵循的约定——尽管表将包含多个人，但我们总是使用单数形式命名类。"

#: ../../peewee/quickstart.rst:64
msgid ""
"There are lots of :ref:`field types <fields>` suitable for storing "
"various types of data. Peewee handles converting between *pythonic* "
"values those used by the database, so you can use Python types in your "
"code without having to worry."
msgstr ""
"在Peewee中，包含多种字段类型用来存储各种类型的数据。Peewee自动处理数据库类型"
"和Python类型之间的转换，因此您可以在代码中使用Python类型而无需担心。"

#: ../../peewee/quickstart.rst:69
msgid ""
"Things get interesting when we set up relationships between models using "
":ref:`foreign key relationships <relationships>`. This is simple with "
"peewee:"
msgstr ""
"当我们使用外键关系在模型之间建立关系时，情况会变得有趣起来。实现很简单："

#: ../../peewee/quickstart.rst:82
msgid ""
"Now that we have our models, let's connect to the database. Although it's"
" not necessary to open the connection explicitly, it is good practice "
"since it will reveal any errors with your database connection "
"immediately, as opposed to some arbitrary time later when the first query"
" is executed. It is also good to close the connection when you are done "
"-- for instance, a web app might open a connection when it receives a "
"request, and close the connection when it sends the response."
msgstr ""
"我们已经有了模型，现在让我们连接到数据库。尽管不必显式打开连接，但这是一种良好的做法，"
"因为它将立即显示数据库连接的任何错误，而不是在以后执行第一个查询时发现。在使用完成后，"
"最好显式关闭连接——例如，web应用程序中在收到请求时打开连接，在发送响应时关闭连接。"

#: ../../peewee/quickstart.rst:94
msgid ""
"We'll begin by creating the tables in the database that will store our "
"data. This will create the tables with the appropriate columns, indexes, "
"sequences, and foreign key constraints:"
msgstr ""
"我们将首先在数据库中创建存储数据的表。以下操作将创建具有定义的列、索引、序列和外键约束的表："

#: ../../peewee/quickstart.rst:105
msgid "Storing data"
msgstr "保存数据"

#: ../../peewee/quickstart.rst:107
msgid ""
"Let's begin by populating the database with some people. We will use the "
":py:meth:`~Model.save` and :py:meth:`~Model.create` methods to add and "
"update people's records."
msgstr ""
"我们通过增加一些人员信息来填充数据库。我们将使用:py:meth:`~Model.save`和"
":py:meth:`~Model.create`方法添加和更新用户的记录。"

#: ../../peewee/quickstart.rst:119
msgid ""
"When you call :py:meth:`~Model.save`, the number of rows modified is "
"returned."
msgstr "调用:py:meth:`~Model.save`时，将返回修改的行数。"

#: ../../peewee/quickstart.rst:122
msgid ""
"You can also add a person by calling the :py:meth:`~Model.create` method,"
" which returns a model instance:"
msgstr ""
"还可以通过调用:py:meth:`~Model.create`方法添加一个人员信息，该方法返回一个模型实例。"

#: ../../peewee/quickstart.rst:130
msgid ""
"To update a row, modify the model instance and call "
":py:meth:`~Model.save` to persist the changes. Here we will change "
"Grandma's name and then save the changes in the database:"
msgstr ""
"如果想更新行数据，请修改模型实例并调用:py:meth:`~Model.save`来保存更改。"
"下面将演示修改Grandma名字然后保存到数据库中："

#: ../../peewee/quickstart.rst:140
msgid ""
"Now we have stored 3 people in the database. Let's give them some pets. "
"Grandma doesn't like animals in the house, so she won't have any, but "
"Herb is an animal lover:"
msgstr ""
"现在数据库中已经存储了3个人，让我们给他们增加一些宠物。Grandma不喜欢家里的动物，"
"所以她不会有，但Herb是个动物爱好者："

#: ../../peewee/quickstart.rst:151
msgid ""
"After a long full life, Mittens sickens and dies. We need to remove him "
"from the database:"
msgstr ""
"在漫长的一生之后，Mittens生病去世，所以需要把它从数据库中删除："

#: ../../peewee/quickstart.rst:160
msgid ""
"The return value of :py:meth:`~Model.delete_instance` is the number of "
"rows removed from the database."
msgstr "函数:py:meth:`~Model.delete_instance`的返回值是从数据库中删除的行数。"

#: ../../peewee/quickstart.rst:163
msgid ""
"Uncle Bob decides that too many animals have been dying at Herb's house, "
"so he adopts Fido:"
msgstr "Bob认为Herb家里死了太多的动物，所以他收养了Fido"

#: ../../peewee/quickstart.rst:174
msgid "Retrieving Data"
msgstr "检索数据"

#: ../../peewee/quickstart.rst:176
msgid ""
"The real strength of our database is in how it allows us to retrieve data"
" through *queries*. Relational databases are excellent for making ad-hoc "
"queries."
msgstr ""
"Peewee的真正优势在于它允许我们以各种方式查询检索数据。而关系数据库非常适合进行随机查询。"

#: ../../peewee/quickstart.rst:181
msgid "Getting single records"
msgstr "获取单个记录"

#: ../../peewee/quickstart.rst:183
msgid ""
"Let's retrieve Grandma's record from the database. To get a single record"
" from the database, use :py:meth:`Select.get`:"
msgstr ""
"接下来我们从数据库中检索Grandma的记录。要从数据库中获取单个记录，请使用"
":py:meth:`Select.get`："

#: ../../peewee/quickstart.rst:190
msgid "We can also use the equivalent shorthand :py:meth:`Model.get`:"
msgstr "我们也可以使用等效简写形式 :py:meth:`Model.get`："

#: ../../peewee/quickstart.rst:197
msgid "Lists of records"
msgstr "记录列表"

#: ../../peewee/quickstart.rst:199
msgid "Let's list all the people in the database:"
msgstr "我们来列出数据库中所有的人员："

#: ../../peewee/quickstart.rst:211
msgid "Let's list all the cats and their owner's name:"
msgstr "我们来列出所有的猫和它们的主人名字："

#: ../../peewee/quickstart.rst:224
msgid ""
"There is a big problem with the previous query: because we are accessing "
"``pet.owner.name`` and we did not select this relation in our original "
"query, peewee will have to perform an additional query to retrieve the "
"pet's owner.  This behavior is referred to as :ref:`N+1 <nplusone>` and "
"it should generally be avoided."
msgstr ""
"上一个查询有一个大问题：因为我们正在访问``pet.owner.name``，并且我们在原始查询"
"中没有选择此关系，所以peewee必须执行一个附加查询来检索宠物的主人。这种行为称为N+1，"
"通常应避免。"


#: ../../peewee/quickstart.rst:230
msgid ""
"For an in-depth guide to working with relationships and joins, refer to "
"the :ref:`relationships` documentation."
msgstr "有关使用关系和联接的深入指南，请参阅:ref:`relationships`文档。"

#: ../../peewee/quickstart.rst:233
msgid ""
"We can avoid the extra queries by selecting both *Pet* and *Person*, and "
"adding a *join*."
msgstr "在检索Pet和Person信息时，可以添加一个*join*来避免额外的查询。"

#: ../../peewee/quickstart.rst:250
msgid "Let's get all the pets owned by Bob:"
msgstr "我们来检索Bob的所有宠物："

#: ../../peewee/quickstart.rst:261
msgid ""
"We can do another cool thing here to get bob's pets. Since we already "
"have an object to represent Bob, we can do this instead:"
msgstr ""
"我们可以通过另一种很酷的方法来得到鲍勃的宠物。因为我们已经有一个对象来表示Bob，"
"所以我们可以这样做："

#: ../../peewee/quickstart.rst:270
msgid "Sorting"
msgstr "排序"

#: ../../peewee/quickstart.rst:272
msgid ""
"Let's make sure these are sorted alphabetically by adding an "
":py:meth:`~Select.order_by` clause:"
msgstr ""
"我们可以通过添加:py:meth:`~Select.order_by`来确保结果按字母顺序排序："

#: ../../peewee/quickstart.rst:284
msgid "Let's list all the people now, youngest to oldest:"
msgstr "现在让我们从小到大列出所有的人："

#: ../../peewee/quickstart.rst:297
msgid "Combining filter expressions"
msgstr "组合筛选表达式"

#: ../../peewee/quickstart.rst:299
msgid ""
"Peewee supports arbitrarily-nested expressions. Let's get all the people "
"whose birthday was either:"
msgstr "Peewee支持任意嵌套的表达式。让我们把所有生日符合一下条件的筛选出来："

#: ../../peewee/quickstart.rst:302
msgid "before 1940 (grandma)"
msgstr "小于1940 (grandma)"

#: ../../peewee/quickstart.rst:303
msgid "after 1959 (bob)"
msgstr "大于1959(bob)"

#: ../../peewee/quickstart.rst:320
msgid "Now let's do the opposite. People whose birthday is between 1940 and 1960:"
msgstr "现在让我们反过来做，筛选1940年至1960年间生日的人："

#: ../../peewee/quickstart.rst:335
msgid "Aggregates and Prefetch"
msgstr "聚合和预取"

#: ../../peewee/quickstart.rst:337
msgid "Now let's list all the people *and* how many pets they have:"
msgstr "现在让我们列出所有的人和他们的宠物数量："

#: ../../peewee/quickstart.rst:349
msgid ""
"Once again we've run into a classic example of :ref:`N+1 <nplusone>` "
"query behavior. In this case, we're executing an additional query for "
"every ``Person`` returned by the original ``SELECT``! We can avoid this "
"by performing a *JOIN* and using a SQL function to aggregate the results."
msgstr ""
"我们再次遇到一个N+1查询行为的经典示例。在本例中，我们对原始SELECT返回的每个人"
"执行一个附加查询！我们可以通过执行JOIN并使用SQL函数来聚合结果来避免这种情况。"

#: ../../peewee/quickstart.rst:372
msgid ""
"Peewee provides a magical helper :py:func:`fn`, which can be used to call"
" any SQL function. In the above example, "
"``fn.COUNT(Pet.id).alias('pet_count')`` would be translated into "
"``COUNT(pet.id) AS pet_count``."
msgstr ""
"Peewee提供了一个神奇的函数:py:func:`fn`，可以用来调用任何SQL函数。在上面的例子中，"
"``fn.COUNT(Pet.id).alias('pet_count')``将转换为``COUNT(pet.id) AS pet_count``。"

#: ../../peewee/quickstart.rst:376
msgid ""
"Now let's list all the people and the names of all their pets. As you may"
" have guessed, this could easily turn into another :ref:`N+1 <nplusone>` "
"situation if we're not careful."
msgstr ""
"现在让我们列出所有人和他们所有宠物的名字。你可能已经猜到了，如果我们不小心的话，"
"这很容易变成另一个N+1的情况。"

#: ../../peewee/quickstart.rst:380
msgid ""
"Before diving into the code, consider how this example is different from "
"the earlier example where we listed all the pets and their owner's name. "
"A pet can only have one owner, so when we performed the join from ``Pet``"
" to ``Person``, there was always going to be a single match. The "
"situation is different when we are joining from ``Person`` to ``Pet`` "
"because a person may have zero pets or they may have several pets. "
"Because we're using a relational databases, if we were to do a join from "
"``Person`` to ``Pet`` then every person with multiple pets would be "
"repeated, once for each pet."
msgstr ""
 "在写这段代码之前，考虑一下这个例子与前面的例子有什么不同，我们列出了所有宠物及 "
"其主人的名字。宠物只能有一个主人，所以当我们执行从``Pet``到``Person``的连接时，"
"总是会有一个匹配项。但当我们将``Person``连接``Pet``时，情况就不同了，因为一个人"
"可能没有宠物，或者他们可能有几个宠物。因为我们使用的是关系数据库，如果我们要从"
"``Person``连接``Pet``时，那么每个有多个宠物的人员信息都会被重复添加到他的宠物一次。"

#: ../../peewee/quickstart.rst:389
msgid "It would look like this:"
msgstr "代码如下："

#: ../../peewee/quickstart.rst:411
msgid ""
"Usually this type of duplication is undesirable. To accommodate the more "
"common (and intuitive) workflow of listing a person and attaching **a "
"list** of that person's pets, we can use a special method called "
":py:meth:`~ModelSelect.prefetch`:"
msgstr ""
"通常这种复制是不可取的。为了实现列出每个人及其宠物的功能，我们需要使用一种更常见"
"（更直观）的方法:py:meth:`~ModelSelect.prefetch`："

#: ../../peewee/quickstart.rst:433
msgid "SQL Functions"
msgstr "SQL函数"

#: ../../peewee/quickstart.rst:435
msgid ""
"One last query. This will use a SQL function to find all people whose "
"names start with either an upper or lower-case *G*:"
msgstr ""
"接下来是最后一个查询示例。这将使用一个SQL函数来查找所有名字以大写或小写字母*G*开头的人："

#: ../../peewee/quickstart.rst:447
msgid ""
"This is just the basics! You can make your queries as complex as you "
"like. Check the documentation on :ref:`querying` for more info."
msgstr ""
"以上的例子只是一些基础，您可以使查询尽可能复杂。查看有关文档:ref:`querying`来获得更多的信息。"

#: ../../peewee/quickstart.rst:451
msgid "Database"
msgstr "数据库"

#: ../../peewee/quickstart.rst:453
msgid "We're done with our database, let's close the connection:"
msgstr "我们数据库已经使用完毕，现在关闭数据库："

#: ../../peewee/quickstart.rst:459
msgid ""
"In an actual application, there are some established patterns for how you"
" would manage your database connection lifetime. For example, a web "
"application will typically open a connection at start of request, and "
"close the connection after generating the response. A :ref:`connection "
"pool <connection_pooling>` can help eliminate latency associated with "
"startup costs."
msgstr ""
"在实际的应用程序中，对于管理数据库连接生存期，有一些已有的模式。例如，web应用程序"
"通常会在请求开始时打开连接，并在生成响应后关闭连接。可以使用:ref:`connection"
" pool <connection_pooling>`来帮助减少与启动成本相关的延迟。"

#: ../../peewee/quickstart.rst:465
msgid ""
"To learn about setting up your database, see the :ref:`database` "
"documentation, which provides many examples. Peewee also supports "
":ref:`configuring the database at run-time <deferring_initialization>` as"
" well as setting or changing the database at any time."
msgstr ""
"要了解如何设置数据库，请参阅:ref:`database`文档，其中提供了许多示例。"
"Peewee还支持在运行时配置数据库:ref:`configuring the database at "
"run-time <deferring_initialization>`，以便随时设置或更改数据库。"

#: ../../peewee/quickstart.rst:470
msgid "Working with existing databases"
msgstr "使用现有数据库"

#: ../../peewee/quickstart.rst:472
msgid ""
"If you already have a database, you can autogenerate peewee models using "
":ref:`pwiz`. For instance, if I have a postgresql database named "
"*charles_blog*, I might run:"
msgstr ""
"如果已经有了数据库，可以使用模型生成器pwiz自动生成peewee模型。例如，如果我有一个"
"名为charles_blog的postgresql数据库，我可以运行："

#: ../../peewee/quickstart.rst:481
msgid "What next?"
msgstr "接下来呢？"

#: ../../peewee/quickstart.rst:483
msgid ""
"That's it for the quickstart. If you want to look at a full web-app, "
"check out the :ref:`example-app`."
msgstr ""
"这就是快速入门。如果您想查看完整的web应用程序，请查看示例应用程序 :ref:`example-app`。"

